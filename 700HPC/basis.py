# -*- coding: utf-8 -*-
"""HPC_Project.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wwR9YMn0VMq5g_KN2sROR51GzqY4jBCF

# Standard Sorts
"""

def bubble_sort(Array):

    n = len(Array)
    for i in range(n-1):
        flag = True
        for j in range(n-i-1):
            if Array[j] > Array[j+1]:
                flag = False
                Array[j], Array[j+1] = Array[j+1], Array[j]
        if flag:
            break
    return Array

def merge_sort(arr):
    if len(arr) <= 1:
        return arr

    mid = len(arr) // 2
    leftHalf = arr[:mid]
    rightHalf = arr[mid:]

    sortedLeft = merge_sort(leftHalf)
    sortedRight = merge_sort(rightHalf)

    return merge(sortedLeft, sortedRight)


def merge(left, right):
    result = []
    i = j = 0
    while i < len(left) and j < len(right):
        if left[i] < right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    # Append any remaining elements
    result.extend(left[i:])
    result.extend(right[j:])
    return result

"""

# *Pseudocode For hybrid sort*#"""

def Hybrid_sort_700(Arr):
  n = len(Arr)
  # threshold = 50
  threshold =32
  # Bubble sort for arrays smaller than the threshold
  if n <= threshold:
    return bubble_sort(Arr)

  size = threshold
  subarrays = []

  # Bubble sort for sliced subarrays
  for i in range(0, n, size):
    # Maybe add some techniques here
    subArr = Arr[i:i+size]
    subarrays.append(bubble_sort(subArr))

  while len(subarrays) > 1:
    result = []
    # Process pairs of subarrays
    for i in range(0, len(subarrays), 2):
      if i + 1 < len(subarrays):
        result.append(merge(subarrays[i], subarrays[i+1]))
      else:
        result.append(subarrays[i])
    subarrays = result
  return subarrays[0] if subarrays else []

"""# *Adding Dynamic Runs*"""

def bubble_early_stop(Array):
    n = len(Array)
    arr = Array.copy()
    for i in range(n - 1):
        flag = True
        for j in range(n - i - 1):
            if arr[j] > arr[j + 1]:
                flag = False
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
        if flag:
            break
    return arr

def insertion_sort(arr):
    arr = arr.copy()
    n = len(arr)
    for i in range(1, n):
        key = arr[i]
        j = i - 1
        while j >= 0 and arr[j] > key:
            arr[j+1] = arr[j]
            j -= 1
        arr[j+1] = key
    return arr

def detect_run_fixed(arr, start, threshold):
    n = len(arr)
    i = start
    while i + 1 < n and arr[i] <= arr[i + 1]:
        i += 1
    natural_run_length = i - start + 1

    if natural_run_length < threshold // 2:
        end = min(start + threshold, n)
        return arr[start:end], end
    else:
        end = min(start + threshold, n)
        return arr[start:end], end

def Hybrid_sort_700_run(arr, threshold=10):
    n = len(arr)
    if n <= threshold:
        return bubble_early_stop(arr)

    runs = []
    i = 0
    while i < n:
        run, next_i = detect_run_fixed(arr, i, threshold)
        sorted_run = bubble_early_stop(run)
        runs.append(sorted_run)
        i = next_i

    while len(runs) > 1:
        merged = []
        for j in range(0, len(runs), 2):
            if j + 1 < len(runs):
                merged.append(merge(runs[j], runs[j + 1]))
            else:
                merged.append(runs[j])
        runs = merged

    return runs[0] if runs else []



def is_sorted(arr):
    return all(arr[i] <= arr[i+1] for i in range(len(arr)-1))

def Hybrid_sort_700_run_sorted(arr, threshold=32):
    n = len(arr)

    if is_sorted(arr):
        return arr.copy()

    if n <= threshold:
        return bubble_early_stop(arr)

    runs = []
    i = 0
    while i < n:
        run, next_i = detect_run_fixed(arr, i, threshold)
        sorted_run = bubble_early_stop(run)
        runs.append(sorted_run)
        i = next_i

    while len(runs) > 1:
        merged = []
        for j in range(0, len(runs), 2):
            if j + 1 < len(runs):
                merged.append(merge(runs[j], runs[j + 1]))
            else:
                merged.append(runs[j])
        runs = merged

    return runs[0] if runs else []

def tim_run_detect_sorted(arr, threshold=32):
    n = len(arr)
    if is_sorted(arr):
        return arr.copy()

    if n <= threshold:
        return insertion_sort(arr)

    runs = []
    i = 0
    while i < n:
        run, next_i = detect_run_fixed(arr, i, threshold)
        sorted_run = insertion_sort(run)
        runs.append(sorted_run)
        i = next_i

    while len(runs) > 1:
        merged = []
        for j in range(0, len(runs), 2):
            if j + 1 < len(runs):
                merged.append(merge(runs[j], runs[j + 1]))
            else:
                merged.append(runs[j])
        runs = merged

    return runs[0] if runs else []

# TimSort implementation adapted from https://gist.github.com/ruminations/89a045dc0ef7edfb92304a0de0752ee0
class TimSort(list):
    __slots__=('_s','_t','_k','_mg')

    def __init__(self,data):
        super(TimSort,self).__init__(data)
        self._s,self._t,self._k,self._mg = [],[],(lambda v:v),7

    def _cmp(self,i,j,tmp=None):
        a =  self._t if (tmp is False) else self
        b =  self._t if (tmp is True ) else self
        return self._k(a[i]) < self._k(b[j])

    def insort(self,start=0,end=None,index=0):
        index = start + max(index - start, 1)
        for i in range(index, end):
            v = self[i]
            j = self._h_place(i, start, i)
            for k in range(i, j, -1): self[k] = self[k - 1]
            self[j] = v

    def reverse(self,start=0,end=None):
        i,j = start,(len(self)-1) if (end is None) else (end-1)
        while i < j:
            self[i],self[j] = self[j],self[i]
            i += 1; j -= 1

    def _h_place(self,index,start,end,tmp=None):
        i,j = 0,end-start
        while i < j:
            m = (i+j)//2
            i,j = (i,m) if (self._cmp(index, start + m, tmp)) else (m+1,j)
        return start+i

    def _l_place(self,index,start,end,tmp=None):
        i,j = 0,end-start
        while i < j:
            m = (i+j)//2
            i,j = (i,m) if (not self._cmp(start + m, index, tmp)) else (m+1,j)
        return start+i

    def sort(self,key=None,reverse=False):
        self._k = key if key else (lambda v:v)
        l = len(self)
        if l < 2: return
        mr = self.minrun; re = 0; asc = None; self._s = []
        try:
            while True:
                rs,re = re,re+1
                self._s.append(rs)
                while self.invariant is False: self.merge
                asc = not self._cmp(re,rs)
                while asc ^ self._cmp(re,re-1): re += 1
                if not asc: self.reverse(rs,re)
                asc = None
                if (re - rs) < mr:
                    self.insort(rs, rs + mr, re); re = rs + mr
        except IndexError:
            if asc is False: self.reverse(rs,re)
            if self._s[-1] != l: self._s.append(l)
            while len(self._s) > 2: self.merge
            if reverse: self.reverse()

    @property
    def invariant(self):
        l = len(self._s)
        if l < 3: return True
        c,b,a = self._s[-3:]; B,A = b-c,a-b
        if l == 3: return (B > A)
        d = self._s[-4]; C = c - d
        if l == 4: return (B > A) and (C > B + A)
        e = self._s[-5]; D = d - e
        return (B > A) and (C > B + A) and (D > C + B)

    @property
    def minrun(self):
        r,l = 0,len(self)
        while l >= 64: r,l = r | (l & 1), l >> 1
        return r + l

    @property
    def merge(self):
        if len(self._s) == 2: return
        a = self._s.pop(); b = self._s.pop(); c = self._s[-1]; B,A = b-c,a-b
        if len(self._s) == 1: self._s.append(a)
        else:
            self._s.pop(); d = self._s[-1]; C = c - d
            if C < A:
                self._s.extend([b, a]); B,A = C,B; c,b,a = d,c,b
            else:
                self._s.extend([c, a])
        g = 0
        if B <= A:
            c = self._h_place(b, c, b)
            B = b - c
            self._t = self[c:b]; i,j,k = 0,b,c
            while i < B and j < a:
                if self._cmp(j,i,True):
                    self[k] = self[j]; j += 1
                    g = 0 if (g < 0) else g + 1
                else:
                    self[k] = self._t[i]; i += 1
                    g = 0 if (g > 0) else g - 1
                k += 1
            while i < B: self[k] = self._t[i]; i += 1; k += 1
        else:
            a = self._l_place(b-1, b, a)
            A = a - b
            self._t = self[b:a]; i,j,k = A-1,b-1,a-1
            while i >= 0 and c-1 < j:
                if self._cmp(i,j,False):
                    self[k] = self[j]; j -= 1
                    g = 0 if (g < 0) else g + 1
                else:
                    self[k] = self._t[i]; i -= 1
                    g = 0 if (g > 0) else g - 1
                k -= 1
            while i >= 0: self[k] = self._t[i]; i -= 1; k -= 1

def run_timsort(arr):
    t = TimSort(arr)
    t.sort()
    return list(t)

#Timsort from Ashok

minrun = 32

def InsSort(arr, start, end):
    for i in range(start + 1, end + 1):
        elem = arr[i]
        j = i - 1
        while j >= start and elem < arr[j]:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = elem
    return arr

def timsort_merge(arr, start, mid, end):
    if mid == end:
        return arr
    first = arr[start:mid+1]
    last = arr[mid+1:end+1]
    len1 = mid - start + 1
    len2 = end - mid
    ind1 = 0
    ind2 = 0
    ind  = start

    while ind1 < len1 and ind2 < len2:
        if first[ind1] < last[ind2]:
            arr[ind] = first[ind1]
            ind1 += 1
        else:
            arr[ind] = last[ind2]
            ind2 += 1
        ind += 1

    while ind1 < len1:
        arr[ind] = first[ind1]
        ind1 += 1
        ind += 1

    while ind2 < len2:
        arr[ind] = last[ind2]
        ind2 += 1
        ind += 1

    return arr

def timsort_colleague(arr):
    n = len(arr)
    arr = arr.copy()

    for start in range(0, n, minrun):
        end = min(start + minrun - 1, n - 1)
        arr = InsSort(arr, start, end)

    curr_size = minrun
    while curr_size < n:
        for start in range(0, n, curr_size * 2):
            mid = min(n - 1, start + curr_size - 1)
            end = min(n - 1, mid + curr_size)
            arr = timsort_merge(arr, start, mid, end)
        curr_size *= 2
    return arr

def run_timsort_colleague(arr):
    return timsort_colleague(arr)

# A simple testing code, haven't used our dataset yet
import random
import time

N = 100000
test_array = [random.uniform(0, 100000) for _ in range(N)]

def is_sorted(arr):
  return all(arr[i] <= arr[i+1] for i in range(len(arr)-1))

import numpy as np
# Inference function: Pass in the test array and the sorting function name as parameter
def inference(sort_name, arr):
  results = []
  for i in range(100):
    start = time.perf_counter()
    answer = sort_name(arr)
    end = time.perf_counter()
    single_runtime = (end - start)
    results.append(single_runtime)
  _mean = np.mean(results)
  _std = np.std(results)
  _median = np.median(results)
  _min = np.min(results)
  _max = np.max(results)
  print(results)
  print("""Execution time summary:
  {:^12} {:^12} {:^12} {:^12} {:^12}
  {:^12.4f} {:^12.4f} {:^12.4f} {:^12.4f} {:^12.4f}
                """.format(
              "mean (ms)",
              "median (ms)",
              "max (ms)",
              "min (ms)",
              "std (ms)",
          _mean * 1000,
          _median * 1000,
          _max * 1000,
          _min * 1000,
          _std * 1000,
              ))
'''
print("Inference for static sort")
inference(Hybrid_sort_700, test_array)
print("Inference for Dynamic sort")
inference(Hybrid_sort_700_run, test_array)

print("Inference for Collegue sort")
inference(timsort_colleague, test_array)
print("Inference for merge sort")
inference(merge_sort, test_array)
'''
# # Test Bubble Sort
# arr1 = test_array.copy()
# start = time.perf_counter()
# bubble_sorted = bubble_sort(arr1)
# end = time.perf_counter()
# print(f"[Bubble Sort] Time: {end - start:.4f} sec | Sorted? {is_sorted(bubble_sorted)}")

# # Test Merge Sort
# arr2 = test_array.copy()
# start = time.perf_counter()
# merge_sorted = merge_sort(arr2)
# end = time.perf_counter()
# print(f"[Merge Sort ] Time: {end - start:.4f} sec | Sorted? {is_sorted(merge_sorted)}")

# Test Hybrid_sort_700
# arr3 = test_array.copy()
# start = time.perf_counter()
# hybrid_sorted = Hybrid_sort_700(arr3)
# end = time.perf_counter()
# print(f"[Hybrid700  ] Time: {end - start:.4f} sec | Sorted? {is_sorted(hybrid_sorted)}")

# # Test TimSort(GitHub version)
# arr5 = test_array.copy()
# start = time.perf_counter()
# timsort_sorted = run_timsort(arr5)
# end = time.perf_counter()
# print(f"[TimSort_Real] Time: {end - start:.4f} sec | Sorted? {is_sorted(timsort_sorted)}")

# # Test TimSort(Python default one)
# arr6 = test_array.copy()
# start = time.perf_counter()
# arr6.sort()
# end = time.perf_counter()
# print(f"[Python sort] Time: {end - start:.4f} sec | Sorted? {is_sorted(arr6)}")

# arr7 = test_array.copy()
# start = time.perf_counter()
# hybrid_sorted = Hybrid700_plus_final(arr7)
# end = time.perf_counter()
# print(f"[Hybrid700_Pro  ] Time: {end - start:.4f} sec | Sorted? {is_sorted(hybrid_sorted)}")

# arr8 = test_array.copy()
# start = time.perf_counter()
# hybrid_sorted = Hybrid_sort700_pro_max(arr8)
# end = time.perf_counter()
# print(f"[Hybrid700_Pro_MAX  ] Time: {end - start:.4f} sec | Sorted? {is_sorted(hybrid_sorted)}")

# arr8 = test_array.copy()
# start = time.perf_counter()
# sorted_by_timsort_colleague = run_timsort_colleague(arr7)
# end = time.perf_counter()
# print(f"[TimSort_Ashok] Time: {end - start:.4f} sec | Sorted? {is_sorted(sorted_by_timsort_colleague)}")

import os
import time


def is_sorted(arr):
    return all(arr[i] <= arr[i+1] for i in range(len(arr)-1))

base_path = '/content/sorting-dataset'

results = []

for root, dirs, files in os.walk(base_path):
    for file in files:
        if file.endswith("array.txt"):
            file_path = os.path.join(root, file)
            try:
                with open(file_path, 'r') as f:
                    lines = f.readlines()

                arr = [float(x.strip()) for x in lines]
                arr_copy = arr.copy()

                start = time.time()
                sorted_arr = Hybrid_sort_700_run(arr_copy)
                end = time.time()

                duration = end - start
                sorted_flag = is_sorted(sorted_arr)

                results.append((file_path, duration, sorted_flag))
                print(f"Time taken for {os.path.basename(file_path)}: {duration:.4f} | Sorted? {sorted_flag}")

            except Exception as e:
                print(f"Error processing {file_path}: {e}")

"""# *Baseline Testing*"""

import os
import time
import numpy as np
# import pandas as pd

def is_sorted(arr):
    return all(arr[i] <= arr[i + 1] for i in range(len(arr) - 1))

def inference(sort_func, arr, label=""):
    results = []
    for _ in range(100):
        arr_copy = arr.copy()
        start = time.perf_counter()
        sorted_arr = sort_func(arr_copy)
        end = time.perf_counter()
        results.append(end - start)

    _mean = np.mean(results)
    _std = np.std(results)
    _median = np.median(results)
    _min = np.min(results)
    _max = np.max(results)
    sorted_flag = is_sorted(sorted_arr)

    print(f"Results for {label}:\n")
    print("""Execution time summary:
  {:^12} {:^12} {:^12} {:^12} {:^12}
  {:^12.4f} {:^12.4f} {:^12.4f} {:^12.4f} {:^12.4f}
""".format(
        "mean (ms)",
        "median (ms)",
        "max (ms)",
        "min (ms)",
        "std (ms)",
        _mean * 1000,
        _median * 1000,
        _max * 1000,
        _min * 1000,
        _std * 1000,
    ))

    return {
        'mean': _mean,
        'median': _median,
        'max': _max,
        'min': _min,
        'std': _std,
        'is_sorted': sorted_flag
    }

'''
base_path = '/content/sorting-dataset'
results = []

print("Starting Hybrid_sort_700_run test on all .txt files...\n")

for root, dirs, files in os.walk(base_path):
    for file in files:
        if file.endswith('.txt'):
            file_path = os.path.join(root, file)
            try:
                with open(file_path, 'r') as f:
                    lines = f.readlines()

                arr = [float(x.strip()) for x in lines]
                stats = inference(Hybrid_sort_700_run, arr, label=file)

                results.append({
                    'File': file,
                    'Mean (ms)': stats['mean'] * 1000,
                    'Median (ms)': stats['median'] * 1000,
                    'Max (ms)': stats['max'] * 1000,
                    'Min (ms)': stats['min'] * 1000,
                    'Std (ms)': stats['std'] * 1000
                })

            except Exception as e:
                print(f"Error processing {file_path}: {e}")

df = pd.DataFrame(results)
df.to_csv('hybrid_sort_summary_verbose.csv', index=False)

from IPython.display import display
print("Done! Summary:")
display(df.head())
'''