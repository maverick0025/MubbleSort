# -*- coding: utf-8 -*-
"""HPC_Project.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wwR9YMn0VMq5g_KN2sROR51GzqY4jBCF

# Standard Sorts
"""

def bubble_sort(Array):

    n = len(Array)
    for i in range(n-1):
        flag = True
        for j in range(n-i-1):
            if Array[j] > Array[j+1]:
                flag = False
                Array[j], Array[j+1] = Array[j+1], Array[j]
        if flag:
            break
    return Array

def merge_sort(arr):
    if len(arr) <= 1:
        return arr

    mid = len(arr) // 2
    leftHalf = arr[:mid]
    rightHalf = arr[mid:]

    sortedLeft = merge_sort(leftHalf)
    sortedRight = merge_sort(rightHalf)

    return merge(sortedLeft, sortedRight)


def merge(left, right):
    result = []
    i = j = 0
    while i < len(left) and j < len(right):
        if left[i] < right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    # Append any remaining elements
    result.extend(left[i:])
    result.extend(right[j:])
    return result

"""

# *Pseudocode For hybrid sort*#"""

def Hybrid_sort_700(Arr):
  n = len(Arr)
  # threshold = 50
  threshold =32
  # Bubble sort for arrays smaller than the threshold
  if n <= threshold:
    return bubble_sort(Arr)

  size = threshold
  subarrays = []

  # Bubble sort for sliced subarrays
  for i in range(0, n, size):
    # Maybe add some techniques here
    subArr = Arr[i:i+size]
    subarrays.append(bubble_sort(subArr))

  while len(subarrays) > 1:
    result = []
    # Process pairs of subarrays
    for i in range(0, len(subarrays), 2):
      if i + 1 < len(subarrays):
        result.append(merge(subarrays[i], subarrays[i+1]))
      else:
        result.append(subarrays[i])
    subarrays = result
  return subarrays[0] if subarrays else []

"""# *Adding Dynamic Runs*"""

def bubble_early_stop(Array):
    n = len(Array)
    arr = Array.copy()
    for i in range(n - 1):
        flag = True
        for j in range(n - i - 1):
            if arr[j] > arr[j + 1]:
                flag = False
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
        if flag:
            break
    return arr

def detect_run_fixed(arr, start, threshold):
    n = len(arr)
    i = start
    while i + 1 < n and arr[i] <= arr[i + 1]:
        i += 1
    natural_run_length = i - start + 1

    if natural_run_length < threshold // 2:
        end = min(start + threshold, n)
        return arr[start:end], end
    else:
        end = min(start + threshold, n)
        return arr[start:end], end

def Hybrid_sort_700_run(arr, threshold=32):
    n = len(arr)
    if n <= threshold:
        return bubble_early_stop(arr)

    runs = []
    i = 0
    while i < n:
        run, next_i = detect_run_fixed(arr, i, threshold)
        sorted_run = bubble_early_stop(run)
        runs.append(sorted_run)
        i = next_i

    while len(runs) > 1:
        merged = []
        for j in range(0, len(runs), 2):
            if j + 1 < len(runs):
                merged.append(merge(runs[j], runs[j + 1]))
            else:
                merged.append(runs[j])
        runs = merged

    return runs[0] if runs else []

"""# *Optimization for slow sorted array*"""

def is_sorted(arr):
    return all(arr[i] <= arr[i+1] for i in range(len(arr)-1))

def Hybrid_sort_700_run_sorted(arr, threshold=10):
    n = len(arr)

    if is_sorted(arr):
        return arr.copy()

    if n <= threshold:
        return bubble_early_stop(arr)

    runs = []
    i = 0
    while i < n:
        run, next_i = detect_run_fixed(arr, i, threshold)
        sorted_run = bubble_early_stop(run)
        runs.append(sorted_run)
        i = next_i

    while len(runs) > 1:
        merged = []
        for j in range(0, len(runs), 2):
            if j + 1 < len(runs):
                merged.append(merge(runs[j], runs[j + 1]))
            else:
                merged.append(runs[j])
        runs = merged

    return runs[0] if runs else []

"""# *Optimization for half sorted array*"""

def detect_run_fixed_sorted_check(arr, start, threshold):
    n = len(arr)
    i = start
    while i + 1 < n and arr[i] <= arr[i + 1]:
        i += 1
    natural_run_length = i - start + 1

    if natural_run_length < threshold // 2:
        end = min(start + threshold, n)
        return arr[start:end], end, False
    else:
        end = min(start + threshold, n)
        return arr[start:end], end, True


def Hybrid_sort_700_run_sorted_half(arr, threshold=10):
    n = len(arr)
    if n <= threshold:
        return bubble_early_stop(arr)

    runs = []
    i = 0
    while i < n:
        run, next_i, is_sorted = detect_run_fixed(arr, i, threshold)
        sorted_run = run if is_sorted else bubble_early_stop(run)
        runs.append(sorted_run)
        i = next_i

    while len(runs) > 1:
        merged = []
        for j in range(0, len(runs), 2):
            if j + 1 < len(runs):
                merged.append(merge(runs[j], runs[j + 1]))
            else:
                merged.append(runs[j])
        runs = merged

    return runs[0] if runs else []

"""# *TimSort with Run Detection*"""

def insertion_sort(arr):
    arr = arr.copy()
    n = len(arr)
    for i in range(1, n):
        key = arr[i]
        j = i - 1
        while j >= 0 and arr[j] > key:
            arr[j+1] = arr[j]
            j -= 1
        arr[j+1] = key
    return arr

def tim_run_detect_sorted(arr, threshold=32):
    n = len(arr)
    if is_sorted(arr):
        return arr.copy()

    if n <= threshold:
        return insertion_sort(arr)

    runs = []
    i = 0
    while i < n:
        run, next_i = detect_run_fixed(arr, i, threshold)
        sorted_run = insertion_sort(run)
        runs.append(sorted_run)
        i = next_i

    while len(runs) > 1:
        merged = []
        for j in range(0, len(runs), 2):
            if j + 1 < len(runs):
                merged.append(merge(runs[j], runs[j + 1]))
            else:
                merged.append(runs[j])
        runs = merged

    return runs[0] if runs else []
